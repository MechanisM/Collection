<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>my document</title>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js" type="text/javascript"></script>
	<script src="http://www.kobezzza.com/files/collection/jquery.collection.min.js" type="text/javascript"></script>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	<link type="text/css" rel="stylesheet" href="styles/shCoreDefault.css">
	<script type="text/javascript">SyntaxHighlighter.all();</script>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Использование реляционного фреймворка $.Collection</h1>
	<h2>Глава 8. Шаблонизация.</h2>
	<p>
		Ну вот мы и подошли к кульминации: отображение наших данных  на экране пользователя. Разумеется, в $.Collection уже всё необходимое для  этого есть, но начнём с главного, с шаблона. Шаблон — это такая специальная  JavaScript функция, которая преобразует каждую строку данных $.Collection в  html вид, принцип схож с работой фильтра, т.к. тот возвращал для каждой строки  данных логическое значение. Способов создания шаблона существует несколько:  явное создание шаблона как JavaScript функции или же с помощью DOM инструкции.  Шаблон (template) является стековым параметром, поэтому мы можем использовать  стандартное стековое API для работы с ним, ну а теперь попробуем разобраться на  примере:
	</p>
<pre class="brush: html">&lt;!-- добавим DOM узел, куда поместим результат шаблонизации --&gt;
&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</pre>
	<pre class="brush: js">
// создадим экземпляр $.Collection
var db = new $.Collection([
	{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18}
]);

// создадим шаблон, как функцию и сделаем его активным
db.newTemplate(function (el, i, data, cOLength, cObj, id) {
	return '&lt;p&gt;&lt;b&gt;' + el.name  + '&lt;/b&gt; sex:' + el.sex + '; age:' + el.age + '&lt;/p&gt;';
});

// теперь осталось вызвать метод print и указать, куда выгрузить данные
db.print({target: $(&quot;#result&quot;)});</pre>
	<p>
		Вот и всё! Наши данные успешно отобразились на экране в том  виде, в каком мы указали в шаблоне. Теперь давайте остановимся на параметре  target — это не что иное, как объект jQuery указывающий на то, куда нужно  вставить результат шаблонизации, этот параметр является стековым. Способов же  вставки в DOM существует несколько, по умолчанию используется html, но можно использовать,  например append или prepend, а также все остальные методы jQuery для вставки в  DOM. Параметр, отвечающий за вставку, называется appendType и также является  стековым.
	</p>
	<p>
		Теперь давайте остановимся на методе print: он имеет два  входных параметра, где первым является объект, который может иметь свойства,  определяющие тот или иной стековый параметр, а в случае если он не указан, то  берётся активный. Некоторые входные параметры, например: collection, могут быть  указаны, как отдельная коллекция или в виде строкового ИД-а, указывающего на  коллекцию в стеке. Список параметров, которые поддерживают указания ИД-ов:  collection, template, cache, filter, parser. Все остальные параметры должны  указываться либо в явном виде, либо не указываться.
	</p>
	<p>
		В примере выше мы создавали шаблон, как функцию JS — данный  подход хоть и быстр, но может стать очень запутанным, в виду того, что данные  должны записываться в строчном виде вперемешку с html кодом, поэтому существует  альтернативный способ создания шаблонов.
	</p>
<pre class="brush: html">&lt;!-- создадим описание шаблона напрямую в DOM --&gt;
&lt;script type=&quot;text/ctpl&quot; id=&quot;myTemplate&quot;&gt;
	&lt;p&gt;
		&lt;?js echo el.name; ?&gt; sex: &lt;?js echo el.sex; ?&gt;; age: &lt;?js echo el.age; ?&gt;
	&lt;/p&gt;
&lt;/script&gt;</pre>
<pre class="brush: js">
// вызываем метод print и указываем ему параметры target и template
// при этом нужно предварительно скомпилировать шаблон с помощью специального метода
db.print({
	target: $(&quot;#result&quot;),
	template: $(&quot;#myTemplate&quot;).ctplCompile()
}); // вот и всё!</pre>
<p>
	Как видите: создание через DOM гораздо нагляднее и проще  поддерживаемо, такой метод в большинстве случаев гораздо предпочтительнее, к  тому же, поскольку параметр template стековый, то достаточно один раз  скомпилировать шаблон и добавить его в стек, где он уже будет храниться в виде  просто JS функции. Теперь давайте остановимся на синтаксисе шаблона: тут всё  очень напоминает php вставку в html, т.е. код вставляется между специальными  операторными скобками &lt;?js и ?&gt;. Для вывода в печать, так же как и в php  существует оператор echo, а во всём остальное — это простой JavaScript, т.е. мы  можем объявлять переменные, вызывать функции и т.д. (хотя я не рекомендовал бы  мешать логику с представлением). В конце каждой инструкции обязательно должна  стоять точка с запятой, а комментарии должны быть только многострочные, т.е.  помещённые в /* */. Служебные переменные внутри шаблона, такие же, как и у фильтров.Также стоит отметить необходимость  наличия  корневого тега (в нашем случае — это тег p) — это нужно для избегания возможных  ошибок при постраничной навигации, т.к. количество элементов на странице  считается, как количество прямых потомков параметра target. Однако стековый  параметр calculator может позволить явно указать селектор к элементам, по  которым будет считаться количество элементов. 
</p>
<p>
	Метод print позволяет выводить данные постранично, количество выводимых данных на экран задаётся стековым параметром numberBreak, а номер страницы, с помощью стекового параметра page (метод resetPage сбрасывает page в 1). При это если значение page будет больше, чем есть на самом деле, то будет показана последняя страница из доступных. В случае если используется фильтр и по его запросу не было результатов или исходная коллекция пуста, будет показан специальный стековый параметр resultNull. Вы можете использовать его, например, для того чтобы показать пользователю сообщение, что по его запросу ничего не найдено. Т.к. этот параметр будет вставлен в DOM как есть, то вы можете спокойно использовать в нём html теги.
</p>
<pre class="brush: js">
var db = new $.Collection([
	{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18},
	{name: &quot;Andrey2&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey2&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann2&quot;, sex: &quot;female&quot;, age: 18},
	{name: &quot;Andrey3&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey3&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann3&quot;, sex: &quot;female&quot;, age: 18},
	{name: &quot;Andrey4&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey4&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann4&quot;, sex: &quot;female&quot;, age: 18}
]);

// будем отображать 3 строки на страницу
// и отобразим 2-ю страницу
db.print({
	target: $(&quot;#result&quot;),
	template: $(&quot;#myTemplate&quot;).ctplCompile(),
	numberBreak: 3,
	page: 2
});</pre>
<p>
	Видите, всё довольно просто: мы просто добавили 2 новых  параметра методу (хотя их можно было добавить в стек). Но ещё очень часто к  постраничной выборке необходимо реализовать интерфейс навигации, чтобы  пользователь мог переключать страницы как пожелает сам. Разумеется, это тоже  предусмотренное в $.Collection и для этого выделен стековый параметр pager,  который является jQuery объектом к DOM узлу, в котором будет установлена  навигация, но это ещё не всё. Сам $.Collection в автоматическом режиме не создаёт  интерфейс, т.к. это было бы слишком не мобильным и ограниченным решением, а в  место этого он позволяет использовать специальные пометки, давайте разберём на  примере:
</p>
<pre class="brush: html">&lt;!-- создадим узел для отображения в нём панели навигации --&gt;
&lt;div id=&quot;myPager&quot;&gt;
	&lt;!-- для того чтобы указать, что тег является системным, нужно  добавить специальный класс ctm
		 далее этому узлу нужно добавить специальный data- атрибут data-ctm в который в JSON виде указать все необходимые параметры
		 например, создадим тег, в который будет писаться число записей на странице
	--&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;inPage&quot;}'&gt;&lt;/div&gt;
	
	&lt;!-- номер страницы --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;page&quot;}'&gt;&lt;/div&gt;
	
	&lt;!-- количество страниц --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;nmbOfPages&quot;}'&gt;&lt;/div&gt;
	
	&lt;!-- всего записей, а также зададим класс, который будет добавляться, если данных нету (по умолчанию: noData) --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;total&quot;, &quot;classes&quot;: {&quot;noData&quot;: &quot;empty&quot;}}'&gt;&lt;/div&gt;
	
	&lt;!-- номер первой записи на странице --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;from&quot;}'&gt;&lt;/div&gt;
	
	&lt;!-- номер последней записи на странице --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;info&quot;: &quot;to&quot;}'&gt;&lt;/div&gt;

	&lt;!-- кнопка переключения на предыдущую страницу --&gt;
	&lt;input type=&quot;button&quot; value=&quot;назад&quot; class=&quot;ctm&quot; data-ctm='{&quot;nav&quot;: &quot;prev&quot;}' /&gt;
	
	&lt;!-- кнопка переключения на следующую страницу, также добавим класс в случае, если больше переключаться нельзя (по умолчанию: disabled) --&gt;
	&lt;input type=&quot;button&quot; value=&quot;назад&quot; class=&quot;ctm&quot; data-ctm='{&quot;nav&quot;: &quot;next&quot;, &quot;classes&quot;: {&quot;disabled&quot;: &quot;dis&quot;}}' /&gt;

	&lt;!-- добавим список ссылок, для мгновенного переключения на определённую страницу
		 также укажем тип тега для определения страницы (по  умолчанию: span)
		 класс для активной страницы (по умолчанию: active)
		 и зададим некоторые атрибуты с помощью attr
	 --&gt;
	&lt;div class=&quot;ctm&quot; data-ctm='{&quot;nav&quot;: &quot;pageList&quot;, &quot;classes&quot;: {&quot;active&quot;: &quot;ac&quot;}, &quot;tag&quot;: &quot;a&quot;, &quot;attr&quot;: {&quot;href&quot;, &quot;javascript:;&quot;}}'&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<pre class="brush: js">
// добавим параметр pager
db.print({
	target: $(&quot;#result&quot;),
	template: $(&quot;#myTemplate&quot;).ctplCompile(),
	numberBreak: 3,
	page: 2,
	pager: $(&quot;#myPager&quot;)
});</pre>
<p>
	$.Collection сам создаст необходимые события нажатия для  элементов навигации. Как видите, такой подход позволяет использовать любые теги  и добавлять нужные дополнительные классы. Следует заметить, что за количество ссылок в навигации отвечает стековый параметр pageBreak (его значение должно быть не меньше трёх).
</p>
<h3>Автоматическая сборка шаблонов</h3>
<p>
Как в случае стека, где есть метод автоматической сборки 
—
use, в шаблонах есть похожие инструменты, цель которых минимизировать декларативные определения и сделать синтаксис более понятным и удобным.
</p>
<pre class="brush: html">
&lt;script class=&quot;ctpl&quot; type=&quot;text/ctpl&quot; data-ctpl='{&quot;name&quot;: &quot;tpl1&quot;, &quot;colletion&quot;: &quot;table1&quot;, &quot;print&quot;: true}'&gt;
	&lt;p&gt;
		&lt;?js echo el.name; ?&gt; sex: &lt;?js echo el.sex; ?&gt;; age: &lt;?js echo el.age; ?&gt;
	&lt;/p&gt;
&lt;/script&gt;</pre>
<pre class="brush: js">
// компилируем все шаблоны по селектору
$(&quot;.ctpl&quot;).ctplMake(db);</pre>
<p>
	Давайте разберём, что же делает этот код: в html мы объявили шаблон, а также задали ему дополнительные параметры через data- атрибут, почти все возможные параметры этого атрибута 
—
это свойства первого входного параметра у метода print, кроме некоторых:
</p>
<ul>
	<li>prefix — приставка к имени, в случае если задан, то все указанные параметры сохраняются в стек, как prefix_name;</li>
	<li>name — обязательный параметр, задаёт под каким именем все указанные параметры сохраняются в стеке;</li>
	<li>print — если true, то шаблон будет отрисован сразу после компиляции;</li>
	<li>set — если true, то все указанные параметры делаются активными;</li>
	<li>collection — ИД коллекции из стека, если не указан, то берётся активная.</li>
	</ul>
<p>
Метод 
<span class="brush: js">ctplMake</span>, как <span class="brush: js">и ctplCompile, является расширением jQuery, а в качестве входного параметра принимает экземпляр $.Collection.</span>
</p>
<h3>Парсеры</h3>
<p>
	Иногда на практике бывает нужно осуществить некоторую  пост-обработку текста на экране, например, сделать все слова с http://  настоящими ссылками. В $.Collection для этого реализован механизм парсеров —  это специальная функция, которая осуществляет обработку шаблона непосредственно  перед вставкой в DOM. Т.к. parser —
это стековый параметр, то к нему применимо стековое API, а также, как и фильтр, активный парсер применяется всегда.
</p>
<pre class="brush: js">// создадим несколько парсеров
db.pushParser({
	httpRepl: function (str, cObj) {
		return str.replace(&quot;http&quot;, &quot;&quot;);
	},
	wwwRepl: &quot;:str.replace('url', '');&quot;,
	mix: &quot;httpRepl &amp;&amp; wwwRepl &amp;&amp; (:str.replace('a', 'b'))&quot;
});</pre>
<p>
На примерах выше показаны способы создания парсеров: как простая функция, строкое сокращение функции или строчное условие (возможно использовать только символы логического И (&amp;&amp;)).
</p>
<p>
Параметры функции: str — исходная строка, должна возвращаться модифицируемая, cObj
—
 <span class="brush: js">ссылка на экземпляр $.Collection</span>.
</p>
</body>
</html>
