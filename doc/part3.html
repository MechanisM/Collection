<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>my document</title>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js" type="text/javascript"></script>
	<script src="http://www.kobezzza.com/files/collection/jquery.collection.min.js" type="text/javascript"></script>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	<link type="text/css" rel="stylesheet" href="styles/shCoreDefault.css">
	<script type="text/javascript">SyntaxHighlighter.all();</script>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Использование реляционного фреймворка $.Collection в своём проекте</h1>
	<h2>Глава 3</h2>
	<p>
		Сегодня речь пойдёт о очень мощном механизме $.Collection - о стеке. Но чтобы лучше понять, что же это за зверь начмём с примера:
	</p>
<pre class="brush: js">
// создадим новую коллекцию
var db = new $.Collection([1, 2, 3, 4, 5]);
// затем в процессе работы нам может понадобиться иметь дело с другой коллекцией
// мы можем воспользоваться методом newCollection для замены коллекции в экземпляре db
// однако старая информация будет удалена
db.newCollection([6, 7, 8, 0]);

// одним из решений проблемы является создание нескольких экземпляров
var db1 = new $.Collection([1, 2, 3, 4, 5]), db2 = new $.Collection({a: 1, b: 2});</pre>
<p>
Данный пример плох тем, что приходиться создавать несколько переменных, но главное, что если потребуется взаимодействие между коллекциями, то придётся реализовывать дополнительный интерфейс. Для решений этих проблем на помощь приходит механизм стека $.Collection.
</p>
<pre class="brush: js">
// создадим один экземпляр $.Collection c двумя коллекциями
// одну укажем в конструкторе, а вторую добавим в стек и зададим ей уникальный строковый идентификатор: &quot;table1&quot;
var db = new $.Collection([1, 2, 3, 4, 5]).pushCollection(&quot;table1&quot;, {a: [1, 2], b: 2});

// теперь давайте применем поисковый метод get для коллекции table1
db.get(&quot;a &gt; eq(-1)&quot;, &quot;table1&quot;);</pre>
<p>
	Теперь мы видем, что один экземпляр $.Collection может содержать неогранниченное количество коллекций. Для этого всего лишь нужно воспользоваться методом pushCollection, или универсальным методом _push. Все коллекции хранимые в стеке должны иметь уникальный идентификатор, по которому к ним можно обраться (впринципе в ИД коллекции могут быть любые символы, однако во избежание ошибок воздержитесь от использования специальных для $.Collection символов), а все необходимые методы содержат дополнительный входной параметр для указания ИД. А что же с коллекцией, которая указывается в конструкторе? Дело в том, что она является так называемым &quot;активным параметром&quot;, т.е. применимым по умолчанию и лежит вне стека, хотя у неё тоже есть свой идентификатор, равный &quot;active&quot;.
</p>
<pre class="brush: js">
var db = new $.Collection([1, 2, 3, 4, 5]);

db.get(&quot;:i % 2 === 0&quot;);
db.get(&quot;:i % 2 === 0&quot;, &quot;active&quot;);</pre>
<p>
	Эти два метода get асболютно одинаковы, т.к. обращаются к одной и тойже коллекции, но в большенсве случаев указания ИД для активной коллекции можно опустить.
</p>
<p>
Метод 
pushCollection
имеет 2 вида вызова: первый параметр ИД коллекции, второй сама коллекция или же один входной параметр объект:
</p>
<pre class="brush: js">
db.pushCollection({
	&quot;table1&quot;: [2, 4, 5, 7],
	&quot;temp_table&quot;: [6, [1, [2]]]
});</pre>
<p>
	Как видите, если нам нужно загрузить в стек сразу несколько коллекций, то мы можем это сделать с помощью указания объекта, как входного параметра, где ключ является ИД коллекции. Если нам нужно перезаписать коллекцию в стеке, то просто ещё раз используем метод pushCollection и укажем ИД коллекции, которую хотим перезаписать.
</p>
<pre class="brush: js">
db.pushCollection({
	table1: [2, 4, 5, 7],
	tempTable: [6, [1, [2]]]
});

// перезапишем коллекцию &quot;table1&quot;
db.pushCollection(&quot;table1&quot;, [1, 2]);</pre>
<p>
Если же нам нужно перезаписать активную коллекцию, то необхимо воспользоваться методом newCollection и в качестве единственного входного параметра указываем новое значение дял коллекции. Для удаления коллекций из стека существует метод dropCollection, который принимает неогранниченное количество входных параметров - ИД коллекций в стеке. Можно также в метод 
dropCollection
указать ИД активной коллекции, но результатом работы такого вызова будет значение активнйо коллекции - null.</p>
<pre class="brush: js">
db.dropCollection(&quot;table1&quot;, &quot;active&quot;);
</pre>
<p>
	Существует способ, для того чтобы поменять активность коллекций в стеке, т.е. для того чтобы например не писать каждый раз, что-то типо get(&quot;&quot;, &quot;table1&quot;) мы можем сделать коллекцию table1 активной, для этого нужно использовать метод setCollection и в качестве входного параметра указать ИД коллекции
</p>
<pre class="brush: js">var db = new $.Collection([1, 2, 3, 4, 5]).pushCollection(&quot;table1&quot;, {a: [1, 2], b: 2});

// назначим коллекцию table1 активной
db.setCollection(&quot;table1&quot;);

// теперь методы get можно писать так
db.get(&quot;:el === 2&quot;);
db.get(&quot;:el === 2&quot;, &quot;active&quot;);
db.get(&quot;:el === 2&quot;, &quot;table1&quot;);</pre>
<p>
	Как видете, что теперь на одну и туже коллекциюю можно обратиться по средствам константы active и её ИД из стека. Указание активности коллекции из стека не создаёт новую коллекцию, а просто ссылается на неё. А что же стало с коллекций, которая была указанна в конструкторе? Ответ прост - она была удалена, т.к. её место теперь занимает коллекция table1. Но в этом алгоритме есть один нюанс: если коллекция не имеет места в стеке (например была добавлена через конструктор или метод newCollection), то в случае применения метода setCollection для коллекции из стека - она удалится, а в случае если коллекция была сохранена в стеке, то она просто перестанет быть активной, но никуда не исчезнет.
</p>
<pre class="brush: js">var db = new $.Collection([1, 2, 3, 4, 5]);

db.pushCollection({
	table: [1, 2],
	tmp: [1, 2, 3, 4]
});

// назначим коллекцию table1 активной, коллекция указанная в конструкторе будет удалена
db.setCollection(&quot;table1&quot;);
// теперь назначим активной коллекции tmp, коллекция table1 перестанет быть активной, но останется в стеке и будет доступна по своему уникальному ИД
db.setCollection(&quot;tmp&quot;);

// а теперь назначим активную коллекцию не добавляя её в стек, с помощью метода newCollection
// tmp перестанет быть активной, но останется в стеке
db.newCollection([1, 7, 8]);

// добавим новую коллекцию в стек и сразу назначим её активной, для этого воспользуемся методом pushSetCollection
// коллекция указанная через newCollection будет удалена
db.pushSetCollection(&quot;table2&quot;, [9, 9, 1]);</pre>
<p>
	Эти примеры наглядо показывают, как работает механизм стека. Следует помнить, что если коллекция активна и хранится в стеке, то это не два отдельных обект, а ссылка на один и тот же, и например метод dropCollection удалит коллекцию как из стека так и из активных параметров.
</p>
<p>
У стековых параметров есть так называемая &quot;история активности&quot; - это свойство хранит в себе весь лог изменения статусов активности через метода set и pushSet и позволяет &quot;возвращаться назад&quot;, подобно как это делает кнопка &quot;назад&quot; в браузере. Для реализации этого функционала существует два метода: backCollection и backCollectionIf.
</p>
<pre class="brush: js">
// назначим сначало активной коллекцию table1, а затем tmp
db.setCollection(&quot;table1&quot;).setCollection(&quot;tmp&quot;);
// а теперь вернёмся на один шаг назад по истории используя метод backCollection и сделаем активной снова table1
db.backCollection();

db.setCollection(&quot;tmp&quot;).setCollection(&quot;table1&quot;).setCollection(&quot;tmp&quot;);
// вернёмся на 2 шага назад и сделаем активной tmp
db.backCollection(2);</pre>
<p>
Метод 
backCollectionIf
очень похож на 
backCollection, за одним исключением, что он применяется лишь тогда, когда произошло изменение истории, т.е.:
</p>
<pre class="brush: js">
// назначим сначало активной коллекцию table1, а затем tmp
db.setCollection(&quot;table1&quot;).setCollection(&quot;tmp&quot;).setCollection(&quot;table1&quot;);
db.backCollectionIf(); // tmp активна
db.backCollectionIf(); // tmp активна, т.к. с момента последнего вызова backCollectionIf не было вызовов методов setCollection или pushSetCollection</pre>
<p>
	Следует отметить, что метод newCollection никак не вливяет на историю активности, поэтому методы back и backIf с ним не работают.
</p>
<p>
	На этом данная глава заканчивается, а в следующей мы рассмотрим дополнительны методы для работы со стеком.
</p>
</body>
</html>
