<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>my document</title>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js" type="text/javascript"></script>
	<script src="http://www.kobezzza.com/files/collection/jquery.collection.min.js" type="text/javascript"></script>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	<link type="text/css" rel="stylesheet" href="styles/shCoreDefault.css">
	<script type="text/javascript">SyntaxHighlighter.all();</script>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Использование реляционного фреймворка $.Collection</h1>
	<h2>Глава 9. Дополнительные методы.</h2>
	<p>
	В этой главе будет рассказано про методы, которых нельзя конкретно отнести к той или оной группе, но тем не менее о них нужно знать, т.к. они могут облегчить выполнение некоторого ряда задач.
	</p>
	<h3>		Подробнее про конструктор</h3>
	<p>
		Способов создания экземпляр $.Collection несколько:
	</p>
	<pre class="brush: js">
var
	db = new $.Collection(),
	db2 = $.Collection(),
	db3 = $(&quot;selector&quot;).collection();</pre>
	<p>
		Как видите, использование оператора new не обязательно, поэтому можете выбрать тот вид записи, который вам более нравится. Конструктор $.Collection содержит 2 необязательных параметра:
	 активная коллекция и второй
	- объект активных параметров, например:
	</p>
	<pre class="brush: js">
var db = new $.Collection(&quot;&quot;, {
	filter: &quot;:i % 2 === 0&quot;,
	parser: &quot;:str.replace('http', '')&quot;
});</pre>
<p>
	Теперь давайте подробнее остановимся на способе db3 - создание экземпляров через расширение jQuery, в этом случае $.Collection рекурсивно   обходит узел указанный в jQuery и все его дочерние элементы до тех пор, пока их не   останется, а элементами коллекции становятся сами значения тэга и все его   data- аттрибуты а также значения атрибута <em>class</em> (<em>записываются в специальное свойство <strong>classes</strong></em>).
</p>
		Например у нас есть DOM узел:
	
	</p>
	<pre class="brush: html;">&lt;ul id="mainNode" data-name="parent"&gt;
	&lt;li class="myClass1 myClass2"&gt;1&lt;/li&gt;
	&lt;li&gt;2&lt;/li&gt;

	&lt;li&gt;
		3
		&lt;div data-type="myType"&gt;My DOM&lt;/div&gt;
	&lt;/li&gt;
&lt;/ul&gt;</pre>
	<p>
		Применим для него $.Collection:
	</p>

	<pre class="brush: js;">var myObj = $("#mainNode").collection();</pre>
	<p>
		Наш DOM узел преобразуется в следующий JS-объект (массив):
	</p>
	<pre class="brush: js;">[
	0: {
		name: "parent",
		childNodes: [
			0: {
				val: "1",
				classes: {
					myClass1: "myClass1",
					myClass2: "myClass2"
				}
			},
			1: {
				val: "2"
			},
			2: {
				val: "3",
				childNodes: [
					0: {
						val: "My DOM",
						type: "myType"
					}
				]
			}
		]
	}
]
</pre>
	<p>
		Содержимое тегов (текст)
		добавились в свойства <var>val</var> (<em>обратите внимание, что символы перехода на новую строку были вырезаны</em>), data-атрибуты добавились под своими именами, а классы были помещены в специальный объект.
	Узел указанный в jQuery становится активным параметром target, и также входным параметром можно укзать объед для других активных параметров. Такой вид создания может быть удобным.
	</p>
	<h3>		Отложенные объекты
	</h3>
	<p>
		В jQuery реализован механизм отложенный объектов (jQuery.Deferred). Их удобно использовать, чтобы делать логику нашего AJAX приложения более прозрачной и простой, а не зарываться в бесконечных вложенных callback функциях.
	Поэтому в $.Collection был создан отдельный стековый параметр defer и метод then, который является интерфейсом для метода jQuery then.
	</p>
</body>
</html>
