<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>my document</title>
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js" type="text/javascript"></script>
	<script src="http://www.kobezzza.com/files/collection/jquery.collection.min.js" type="text/javascript"></script>
	<script type="text/javascript" src="scripts/shCore.js"></script>
	<script type="text/javascript" src="scripts/shBrushJScript.js"></script>
	<script type="text/javascript" src="scripts/shBrushXml.js"></script>
	<link type="text/css" rel="stylesheet" href="styles/shCoreDefault.css">
	<script type="text/javascript">SyntaxHighlighter.all();</script>
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<h1>Использование реляционного фреймворка $.Collection</h1>
	<h2>Глава 2. Условные методы.</h2>
	<p>
		В этой главе мы с вами более подробно разберём условные методы $.Collection — это такие методы, которые осуществляют поиск данных в коллекции по указанному условию (фильтру). 
	</p>
	<p>
		Первым методом, который мы рассмотрим, будет уже знакомый вам по прошлой главе метод length.
		Этот метод возвращает длину коллекции в соответствии с указанным условием, например: 
	</p>
	<pre class="brush: js">
var db = new $.Collection([[1, {a: 2}], 2, 3, 4, 5, 5, 6, 2, 1]);

// получим значение свойства a
db.get(&quot;0 &gt; eq(-1) &gt; a&quot;);
// выберем все элементы кратные двум
db.get(":el % 2 === 0"); </pre>
	<p>
		Первым методом, который мы рассмотрим, будет уже знакомый вам по прошлой главе метод get.
		Этот метод 
		осуществляет выборку элементов по заданному условию или прямой ссылке, т.е. в зависимости от входных параметров метод определяет, 
		что же от него хочет разработчик.
	</p>
<pre class="brush: js">
var db = new $.Collection([[1, {a: 2}], 2, 3, 4, 5, 5, 6, 2, 1]);

// получим значение свойства a
db.get(&quot;0 &gt; eq(-1) &gt; a&quot;);
// выберем все элементы кратные двум
db.get(":el % 2 === 0"); </pre>
<p>
	В качестве ответа этот метод всегда возвращает массив значений, и, как вы могли уже догадаться, первым входным параметром получает условие: функцию или строку (строка может быть сокращением функции (тогда она должна начинаться со знака двоеточия) или указателем). Во избежание возможных ошибок воздержитесь от использования в качестве имени ваших свойст специальных символов, таких как: ||, &amp;&amp;, !, (, ), &gt;, eq(), :. В случае если входного параметра нету, то по умолчанию метод вернёт сам исходный объект. Однако данный метод имеет ещё несколько выходных параметров, а их описание вы сможете найти в документации фреймворка.
</p>
<p>
	Следующий метод, который мы рассмотрим, будет схожий по  смыслу метод search. Его интерфейс вызова практически идентичен методу get  (отсутствует возможность задачи прямой ссылки), однако в отличие от get-а, он  возвращает не массив элементом, а массив ключей элементов, т.е.:
</p>
<pre class="brush: js">var db = new $.Collection([1, 2, 3, 4]);

// получим ссылки на элементы, чьё значение больше 2-х
db.search(&quot;:el &gt; 2&quot;); // [2, 3]</pre>
<p>
	У методов get и search есть специальные обёртки: getOn и  searchOne. Отличием является то, что методы осуществляют поиск первого  элемента, который удовлетворяет условию, и возвращать будут уже не массив, а  сам элемент. У метода search есть ещё несколько обёрток, а именно: indexOf и  lastIndexOf. Интерфейс их вызова, как и результат, идентичен нативным методам  массива в JS, поэтому их мы рассматривать не будем.
</p>
<p>
	Далее по списку у нас метод set. Этот метод очень похож на  get, но как видно из названия он не получает, а задаёт значение элементу. Как и  set он поддерживает задачу прямой ссылки или же фильтра условий, а вторым  входным параметром задаётся новое значение для элемента.
</p>
<pre class="brush: js">var db = new $.Collection([1, 2, 3, 4]);

// увеличим на 1 все элементы больше 2-х.
db.set(&quot;:el &gt; 2&quot;, &quot;+=1&quot;); // [1, 2, 4, 5]</pre>
<p>
	Как видите из примера: мы можем использовать сокращения для манипуляций с данными, как и в нативном JavaScript (*=, /=, +=, -=) — это действительно очень удобно! Если же нам нужно просто заменить элемент на другой, то  достаточно  просто указать его. В случае если объект замены — функция, то он выполнится как функция обратного вызова.
</p>
<pre class="brush: js">var db = new $.Collection([1, 2, 3, 4]);

// увеличим на 1 все элементы больше 2-х.
db.set(&quot;:el &gt; 2&quot;, function (el, i, data, cOLength, cObj, id) { return ++el; }); // [1, 2, 4, 5]
</pre>
<p>
	У метода set также есть обёртки: setOne (замена только 1-го элемента) и map. С первым методом всё и так понятно, так что давайте разберём только map. Этот метод первым параметром принимает функцию, которая применется к элементу, а вторым фильтр или прямую ссылку.
</p>
<pre class="brush: js">db = new $.Collection([1, 2, 3, 4]);

// возмём синус для всех не чётных элементов
db.map(Math.sin, &quot;!(:el % 2 === 0)&quot;);</pre>
<p>
	Следующий номер в программе:  методы remove и removeOne. Можно уже догадаться, что эти методы будут удалять элементы из коллекции. Интерфейс их вызова 1 в 1 совпадает с интерфейсом get, поэтому подробно останавливаться на них не будем.
</p>
<p>
	Последний методы, который мы с вами рассмотрим будет пара: group и groupLinks. Они осуществляют группировку элементов коллекции по полю или условию, но ближе к делу:
</p>
<pre class="brush: js">var db = [
	{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22},
	{name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24},
	{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18}
];
db = new $.Collection(db);

// cгруппируем коллекцию по полю sex
db.group(&quot;sex&quot;); // {male: [{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22}, {name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24}], female: [{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18}]}
// а теперь по совершеннолетию (старше 18)
db.group(&quot;:el.age &gt; 18&quot;); // {true: [{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22}, {name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24}], false: [{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18}]};
// можно использовать тернарные операторы
db.group(&quot;:el.age &gt; 18 ? 'yes' : 'no'&quot;); // {yes: [{name: &quot;Andrey&quot;, sex: &quot;male&quot;, age: 22}, {name: &quot;Sergey&quot;, sex: &quot;male&quot;, age: 24}], no: [{name: &quot;Ann&quot;, sex: &quot;female&quot;, age: 18}]};</pre>
<p>
	Помимо прочего, мы также можем использовать функции обратного вызова, для указания условия. Метод group возвращает специальный объект, в качестве ключей которого содержит параметры группировки. Метод groupLinks очень похож на group, но в результирующем объекте возвращает не сами элементы, а ссылки на них, что иногда бывает удобно использовать.
</p>
<p>
Вот и подошла к концу очередная глава про использования замечательного фреймворка $.Collection, а в следующей мы поговрим с вами про очень мощный механизм — стек.
</p>
</body>
</html>
